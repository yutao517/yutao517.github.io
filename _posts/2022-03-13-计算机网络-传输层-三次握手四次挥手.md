---
layout: article
title: 计算机网络-传输层-三次握手四次挥手
tags: 计算机网络
category: blog
date: 2022-03-13 00:00:00 +08:00
mermaid: true
---


[TCP 的重传机制、滑动窗口、流量控制、拥塞控制](https://zhuanlan.zhihu.com/p/381923700)

## 说说TCP/IP的七层模型
- 应用层 (Application)：网络服务与最终用户的一个接口。协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP
- 表示层（Presentation Layer）：数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）
格式有，JPEG、ASCll、DECOIC、加密格式等。
- 会话层（Session Layer）：创建、管理、终止会话。（在五层模型里面已经合并到了应用层）；对应主机进程，指本地主机与远程主机正在进行的会话。
- 传输层 (Transport)：定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层。
- 网络层 (Network)：进行逻辑地址寻址，实现不一样网络之间的路径选择。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP
- 数据链路层 (Link)：创建逻辑链接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）；将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
- 物理层（Physical Layer）：是计算机网络OSI模型中最低的一层；物理层规定:为传输数据所须要的物理链路建立、维持、拆除而提供具备机械的，电子的，功能的和规范的特性；简单的说，物理层确保原始的数据可在各类物理媒体上传输。局域网与广域网皆属第一、2层；物理层是OSI的第一层，它虽然处于最底层，倒是整个开放系统的基础；物理层为设备之间的数据通讯提供传输媒体及互连设备，为数据传输提供可靠的环境；若是您想要用尽可能少的词来记住这个第一层，那就是“信号和介质”。

![image](https://github.com/yutao517/yutao517.github.io/assets/62100249/5722c71b-e56d-4b3e-a6d1-82175150901c)


## 简介

**传输层（Transport Layer）** 主机应用程序之间提供端到端的连接。

**两大传输层协议** 

 1. 传输控制协议TCP (Transport Control Protocol) 
 2. 用户数据报协议UDP (User Datagram Protocol) 

 **1.传输控制协议（TCP）**

 - 用于面向连接的传输
 - 可靠的、面向连接的协议
 -  面向字节流
 
   **2.用户数据报协议（UDP)**
   - 用于简单消息传输
   -  不可靠的、无连接的服务
   -  面向报文
 
 **TCP的工作原理**
 - 连接与断开
 - 流量控制
 - 拥塞控制
 - 差错控制
 - 计时器

 **TCP封装格式**
 
![image](https://github.com/yutao517/yutao517.github.io/assets/62100249/a3ea862e-7966-4908-a44d-b0ad0fac3cc8)

 - URGRNT紧急位，紧急指针有效
 - ACK确认位，确认序号有效
 - PSH急迫位，接收方应该尽快将这个报文交给应用层
 - RESET重置位，重置连接
 - SYNC同步位，发起一个新连接
 - FINISH终止位，释放一个连接

传输层提供逻辑连接的建立、传输层寻址、数据传输、传输连接释放、流量控制、拥塞控制、多路复用和解复用、崩溃恢复等服务。

**端口号**
   - 范围：0-66535（2^16=65536 16位端口号）
-    常用0-1023系统端口
  -  SSH-----22 ，DNS-----53，HTTP-----80
   MYSQL-----3306，远程桌面-----3389，Tomcat-----8080， DNS域名			解析domain-----53
   - Linux记录端口号文件 /etc/services
  -  查看Linux建立的连接netstat -an
 

## TCP三次握手

![image](https://github.com/yutao517/yutao517.github.io/assets/62100249/6ca78494-6e4f-4715-b9f4-c7d1fd3fa834)

以web服务为例
- **第一次握手**：建立连接时，客户端主动发送一个起始序列号seq=x(x随机产生)的TCP报文，标记位为SYN=1，表示“请求建立新连接”，状态变为SYN_SENT，等待服务端的确认。
- **第二次握手**：服务端接收到来自客户端的序列号为seq=x的TCP报文，查看到SYN=1，知道客户端有一个请求建立连接，将客户端的起始序列号x存起来，服务端返回一段TCP报文，报文段的序列号seq=y随机产生，发送确认号ack=x+1，表示确认收到服务器端请求，标志位SYN+ACK的报文段（SYN=1,ACK=1）同意建立连接，结束LISTEN阶段此时服务器进入SYN_RECV状态。
- **第三次握手**：客户端接收到来自服务器端的确认收到数据SYN+ACK报文之后，查看ACK=1，ack=x+1正确，知道服务端收到序列号为x的报文，同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号seq=y给存下来。向服务端返回最后一段序列号seq=x+1的TCP报文，确认号ack=y+1表示收到服务器端同意连接的信号 ，确认结束SYN_SENT阶段，进入ESTABLISHED状态。当服务端收到报文后发现ACK=1并且ack=y+1，就知道客户端收到序列号为y的报文了，客户端和服务端都进入ESTABLISHED（TCP连接成功）状态。

## TCP四次断开

![image](https://github.com/yutao517/yutao517.github.io/assets/62100249/abded439-3d21-45d0-a0ec-e60418c81eb8)

比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。

- **第一次挥手**：假设客户机打算关闭连接，就向其TCP发送一个连接释放报文段，释放连接报文包含FIN标志位FIN=1、序列号seq=u，u是客户端发送数据的最后一个序列号+FIN占据的序列号1，也就是100+1000+1。客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据。
- **第二次挥手**：服务端收到客户端发的FIN报文后给客户端回复确认报文ACK=1，确认号ack=u+1，序列号seq=v，v是服务端发送数据的最后一个序列号也就是300+2000。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于CLOSE-WAIT状态。但服务端可能还有数据没发完，服务器发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。
- **第三次挥手**：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=u+1、序列号seq=w(2300+50)。
- **第四次挥手**：客户端收到服务端发的连接释放报文段后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=w+1(2351)、序列号seq=u+1(1102)。此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。
 
